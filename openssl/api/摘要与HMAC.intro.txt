摘要函数用于将任意数据通过计算获取唯一对应值，而这个值的长度比较短。它是一种
多对一的关系。理论上，这个短的值就对应于原来的数据。这个过程是不可逆的，即不能通
过摘要值来计算原始数据。摘要在信息安全中有非常重要的作用。很多网络应用都通过摘要
计算来存放口令。摘要是安全协议中不可或却的要素，特别是身份认证与签名。用户需要对
数据进行签名时，不可能对大的数据进行运算，这样会严重影响性能。如果只对摘要结果进
行计算，则会提供运算速度。常用摘要算法有：sha、sha1、sha256 以及md5 等。其他还有
md4、md2、mdc2 以及ripemd160 等。

所有的摘要算法都有如下几个函数：
1) XXX_Init
XXX 为具体的摘要算法名称，该函数初始化上下问，用于多数据摘要。
2) XXX_Update
XXX 为具体的摘要算法名称，进行摘要计算，该函数可运行多次，对多个数
据摘要。
3) XXX_Final
XXX 为具体的摘要算法名称，进行摘要计算，该函数与1)和2）一起用。
4) XXX
对一个数据进行摘要。该函数由上述1）2）和3）实现，只是XXX_Update
只调用一次。对应源码为XXX_one.c。
这些函数的测试程序，可参考各个目录下对应的测试程序源码。


摘要是用来防止数据被私自改动的方法，其中用到的函数叫做摘要函数。
这些函数的输入可以是任意大小的信息，但是输出是大小固定的摘要。
摘要有个重要的特性：如果改变了输入信息的任何内容，即使改变一位，输出也将发生不可预知的变化，也就是说输入的任何信息都会影响最后的输出。
总之，摘要算法从一个给定的文本块中产生数字签名，数字签名可以防止有人从签名获取文本信息或者修改文本内容。
摘要算法的数字签名原理在很多加密算法中都有使用，如S/kEY和PGP。


现在流行的摘要算法有MD4和MD5，客户机和服务器必须使用同样的算法。
MD4是麻省理工学院教授Ronald Rivest于1990年设计的一种信息摘要算法。
它是一种用来测试信息完整性的密码散列函数的实行。
其摘要长度为128位，一般128位长的MD4散列被表示为32位的十六进制数字。
这个算法影响了后来的算法如MD5、SHA 家族和RIPEMD等。

1、MD4

MD4(RFC 1320)是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 
的缩写。它适用在32位字长的处理器上用高速软件实现--它是基于 32 
位操作数的位操作来实现的。它的安全性不像RSA那样基于数学假设，尽管 Den 
Boer、Bosselaers 和 Dobbertin 很快就用分析和差分成功的攻击了它3轮变换中的 2 
轮，证明了它并不像期望的那样安全，但它的整个算法并没有真正被破解过，Rivest 
也很快进行了改进。


下面是一些MD4散列结果的例子：
MD4 ("") = 31d6cfe0d16ae931b73c59d7e0c089c0
MD4 ("a") = bde52cb31de33e46245e05fbdbd6fb24
MD4 ("abc") = a448017aaf21d8525fc10ae87aa6729d
MD4 ("message digest") = d9130a8164549fe818874806e1c7014b
MD4 ("12345678901234567890123456789012345678901234567890123456789012345678901234567890") = 
e33b4ddc9c38f2199c3e7b164fcc0536 


2、MD5

MD5(RFC 1321)是 Rivest 
于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 
相同。它较MD4所做的改进是：


1） 加入了第四轮
2） 每一步都有唯一的加法常数；
3） 第二轮中的G函数从((X ∧ Y) ∨ (X ∧ Z) ∨ (Y ∧ Z)) 变为 ((X ∧ Z) ∨ (Y ∧ ～Z))
以减小其对称性；

4） 每一步都加入了前一步的结果，以加快"雪崩效应"；
5)  改变了第2轮和第3轮中访问输入子分组的顺序，减小了形式的相似程度；
6)  近似优化了每轮的循环左移位移量，以期加快"雪崩效应"，各轮的循环左移都不同。

尽管MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好。


消息首先被拆成若干个512位的分组，其中最后512位一个分组是“消息尾+填充字节(100…0)+
64位消息长度”，以确保对于不同长度的消息，该分组不相同。而4个32位寄存器字初始化为
A=0x01234567，B=0x89abcdef，C=0xfedcba98，D=
0x76543210，它们将始终参与运算并形成最终的散列结果。


接着各个512位消息分组以16个32位字的形式进入算法的主循环，512位消息分组的个数据决定了循环的次数。主循环有4轮，每轮分别用到了非线性函数

F(X, Y, Z) = (X ∧ Y) ∨ (～X ∧ Z)
G(X, Y, Z) = (X ∧ Z) ∨ (Y ∧ ～Z)
H(X, Y, Z) =X ⊕ Y ⊕ Z
I(X, Y, Z) = X ⊕ (Y ∨ ～Z)

这4轮变换是对进入主循环的512位消息分组的16个32位字分别进行如下操作：将A、B、C、D的副本a、b、c、d中的3个经F、G、H、I运算后的结果与第4个相加，
再加上32位字和一个32位字的加法常数，并将所得之值循环左移若干位，最后将所得结果加上a、b、c、d之一，并回送至ABCD，由此完成一次循环。


MD5 ("") = d41d8cd98f00b204e9800998ecf8427e
MD5 ("a") = 0cc175b9c0f1b6a831c399e269772661
MD5 ("abc") = 900150983cd24fb0d6963f7d28e17f72
MD5 ("message digest") = f96b697d7cb7938d525a2f31aaf161d0
MD5 ("12345678901234567890123456789012345678901234567890123456789012345678901234567890") = 
57edf4a22be3c955ac49da2e2107b67a